<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Unicorn Runner</title>
<style>
  :root{
    --ground-h: 8px;
    --game-w: 840px;
    --game-h: 260px;
    --fg: #e2e8f0;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;display:grid;place-items:center;overflow:hidden;
    background:linear-gradient(180deg,#0b1220,#0f172a 40%,#111827);
    color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;
  }
  .wrap{width:min(96vw,var(--game-w));}
  .topbar{display:flex;align-items:center;gap:12px;margin:10px 0 8px}
  .title{font-weight:700}
  .spacer{flex:1}
  .namebox{display:flex;gap:8px;align-items:center}
  .input{
    background:#0b1220;border:1px solid #334155;border-radius:10px;
    padding:.45rem .6rem;color:var(--fg);min-width:160px;outline:none;
  }
  .btn{background:#1f2937;color:var(--fg);border:1px solid #334155;padding:.5rem .75rem;border-radius:999px;cursor:pointer;font-weight:600}
  .btn:active{transform:scale(.98)}

  .main{display:grid;grid-template-columns: 1fr 220px; gap:10px}

  /* Game screen + layered skies for crossfade */
  .screen{
    position:relative;height:var(--game-h);border-radius:16px;overflow:hidden;border:1px solid #334155;
    background:#0000;
  }
  .sky{
    position:absolute;inset:0;
    transition:opacity 1800ms linear; /* cloud-like fade */
    opacity:0;
  }
  .sky.visible{ opacity:1; }

  /* Ten DISTINCT, high-drama themes (get ‚Äúcooler‚Äù = more awesome/unique) */
  /* 0‚Üí9: Candy ‚Üí Neon City ‚Üí Tropical ‚Üí Reef ‚Üí Crystal ‚Üí Aurora ‚Üí Cyber Grid ‚Üí Solar Storm ‚Üí Vaporwave ‚Üí Cosmic Nebula */
  .theme-0{ background:linear-gradient(180deg,#ffecb3 0%, #ff9ecb 40%, #ff77aa 65%, #ffd166 100%);}            /* Candy sunrise */
  .theme-1{ background:radial-gradient(100% 90% at 50% 0%, #ffd94d 0%, #ff5ea8 45%, #7c3aed 80%);}              /* Neon city dawn */
  .theme-2{ background:linear-gradient(180deg,#34d399 0%, #22c55e 42%, #10b981 70%, #06b6d4 100%);}             /* Tropical greens/teal */
  .theme-3{ background:radial-gradient(80% 100% at 50% 0%, #67e8f9 0%, #22d3ee 40%, #38bdf8 70%, #2563eb 100%);}/* Ocean reef blues */
  .theme-4{ background:linear-gradient(180deg,#e0e7ff 0%, #c7d2fe 35%, #93c5fd 65%, #60a5fa 100%);}             /* Crystal glacier blue-ice */
  .theme-5{ background:radial-gradient(70% 120% at 50% 0%, #a7f3d0 0%, #22d3ee 35%, #0ea5e9 60%, #312e81 100%);}/* Northern lights aurora */
  .theme-6{ background:linear-gradient(180deg,#06b6d4 0%, #22d3ee 25%, #7c3aed 60%, #0ea5e9 100%);}             /* Cyber grid teal‚Üíviolet */
  .theme-7{ background:radial-gradient(90% 110% at 50% 0%, #fdea7b 0%, #fb923c 30%, #ef4444 55%, #a855f7 85%);} /* Solar storm blaze */
  .theme-8{ background:linear-gradient(180deg,#22d3ee 0%, #a78bfa 35%, #ec4899 65%, #0f172a 100%);}             /* Bold vaporwave */
  .theme-9{ background:radial-gradient(80% 120% at 50% 10%, #7dd3fc22 0%, #312e81 50%, #111827 80%, #000 100%);}/* Cosmic nebula night */

  .hud{position:absolute;left:12px;top:10px;display:flex;gap:14px;font-variant-numeric:tabular-nums;z-index:5}
  .label{opacity:.95}
  .ground{position:absolute;left:0;right:0;bottom:0;height:var(--ground-h);
    background:repeating-linear-gradient(90deg,#065f46 0 18px,#047857 18px 36px);box-shadow:0 -1px 0 #064e3b inset;z-index:5}
  .lane{position:absolute;left:0;right:0;bottom:var(--ground-h);height:4px;opacity:.25;background:repeating-linear-gradient(90deg,#0000 0 14px,#111827 14px 16px);z-index:5}

  .player{--size:62px;position:absolute;left:48px;bottom:var(--ground-h);width:var(--size);height:var(--size);display:grid;place-items:center;filter:drop-shadow(0 3px 0 rgba(0,0,0,.25));z-index:5}
  .sprite{width:100%;height:100%}
  .sprite svg{width:100%;height:100%}
  .player.dead{transform:rotate(-18deg)}

  /* Unicorn animations */
  @keyframes bob { 0%,100%{transform:translateY(0)} 50%{transform:translateY(1.5px)} }
  @keyframes legA { 0%{transform:rotate(16deg)} 50%{transform:rotate(-20deg)} 100%{transform:rotate(16deg)} }
  @keyframes legB { 0%{transform:rotate(-20deg)} 50%{transform:rotate(16deg)} 100%{transform:rotate(-20deg)} }
  @keyframes tailW { 0%{transform:rotate(8deg)} 50%{transform:rotate(-10deg)} 100%{transform:rotate(8deg)} }
  @keyframes maneF { 0%{transform:skewX(2deg)} 50%{transform:skewX(-3deg)} 100%{transform:skewX(2deg)} }
  .run .u-body{animation:bob .26s linear infinite}
  .run .leg-a{transform-origin:6px 4px;animation:legA .22s linear infinite}
  .run .leg-b{transform-origin:6px 4px;animation:legB .22s linear infinite}
  .run .tail{transform-origin:4px 8px;animation:tailW .24s linear infinite}
  .run .mane{transform-origin:12px 10px;animation:maneF .24s linear infinite}
  .leg-a,.leg-b,.tail,.mane,.u-body{animation-play-state:paused}

  .obstacle{
    --w:18px;--h:34px;position:absolute;bottom:var(--ground-h);
    width:var(--w);height:var(--h);
    background:linear-gradient(180deg,#7c3aed,#a78bfa);border:1px solid #6d28d9;border-bottom-color:#4c1d95;border-radius:6px 6px 3px 3px;
    box-shadow:0 3px 0 rgba(0,0,0,.25);
    will-change: transform; contain: content; z-index:5;
  }
  .cloud{
    position:absolute;top:16px;width:70px;height:24px;background:#fff8;border-radius:999px;filter:blur(.3px) drop-shadow(0 2px 0 rgba(0,0,0,.08));
    will-change: transform; contain: content; z-index:4;
  }
  .cloud:before,.cloud:after{content:"";position:absolute;background:#fff8;border-radius:999px}
  .cloud:before{width:28px;height:28px;left:10px;top:-6px}
  .cloud:after{width:38px;height:34px;left:28px;top:-10px}

  .overlay{position:absolute;inset:0;display:grid;place-items:center;background:linear-gradient(#0000,#0002);text-align:center;padding:24px;z-index:6}
  .card{background:#0b1220cc;border:1px solid #334155;border-radius:14px;padding:18px 20px;max-width:520px}
  .card h2{margin:0 0 10px;font-size:20px}
  .card p{margin:6px 0;opacity:.95}
  .kbd{background:#111827;border:1px solid #374151;padding:.15rem .45rem;border-radius:6px}
  .startRow{display:flex;gap:10px;justify-content:center;margin-top:10px}

  .board{height:var(--game-h);border:1px solid #334155;border-radius:16px;padding:10px 12px;overflow:auto;background:#0b1220cc}
  .board h3{margin:0 0 8px;font-size:15px}
  .board ol{margin:0;padding-left:18px}
  .board li{margin:6px 0;font-variant-numeric:tabular-nums}

  @media (max-width:860px){
    .main{grid-template-columns:1fr}
    .board{height:auto}
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="topbar">
    <div class="title">ü¶Ñ Unicorn Runner</div>
    <div class="spacer"></div>
    <div class="namebox">
      <label for="playerName">Name</label>
      <input id="playerName" class="input" maxlength="12" placeholder="Player" />
      <button id="restartBtn" class="btn" aria-label="Restart (R)">Restart</button>
    </div>
  </div>

  <div class="main">
    <div class="screen" id="screen" role="region" aria-label="Unicorn Runner game area">
      <!-- layered skies for crossfading -->
      <div id="skyA" class="sky theme-0 visible" aria-hidden="true"></div>
      <div id="skyB" class="sky theme-0" aria-hidden="true"></div>

      <div class="hud">
        <div class="label">Score: <span id="score">00000</span></div>
        <div class="label">Best: <span id="best">00000</span></div>
        <div class="label">Speed: <span id="speed">1.00x</span></div>
      </div>

      <div class="lane"></div>
      <div id="clouds"></div>

      <div class="player" id="player" aria-label="unicorn">
        <div class="sprite" id="sprite" aria-hidden="true">
          <!-- Cute cartoon unicorn (SVG) -->
          <svg viewBox="0 0 72 52" xmlns="http://www.w3.org/2000/svg">
            <defs>
              <linearGradient id="maneGrad" x1="0" y1="0" x2="1" y2="1">
                <stop offset="0" stop-color="#f472b6"/>
                <stop offset="0.5" stop-color="#60a5fa"/>
                <stop offset="1" stop-color="#22d3ee"/>
              </linearGradient>
              <linearGradient id="tailGrad" x1="0" y1="0" x2="1" y2="1">
                <stop offset="0" stop-color="#a78bfa"/>
                <stop offset="0.5" stop-color="#34d399"/>
                <stop offset="1" stop-color="#fbbf24"/>
              </linearGradient>
            </defs>
            <g class="u-body">
              <path d="M16,28 q10,-14 28,-10 q12,3 14,13 q2,11 -14,14 q-22,4 -28,-6 q-4,-6 0,-11 z" fill="#fff" stroke="#334155" stroke-width="1"/>
              <ellipse cx="50" cy="22" rx="10.5" ry="9" fill="#fff" stroke="#334155" stroke-width="1"/>
              <circle cx="53.5" cy="25" r="2.1" fill="#fca5a5" opacity=".9"/>
              <circle cx="53.2" cy="21" r="1.7" fill="#0f172a"/><circle cx="52.6" cy="20.5" r=".6" fill="#fff" opacity=".9"/>
              <path d="M57 22 q2 1 0 2" stroke="#334155" stroke-width=".8" fill="none" stroke-linecap="round"/>
              <path d="M55 12 l4 -7 l1 8 z" fill="#fde047" stroke="#a16207" stroke-width=".8"/>
              <path class="mane" d="M43 14 c -5 3 -8 7 -10 11 c 4 -2 8 -3 12 -3 c 1 -2 1 -5 -2 -8 z" fill="url(#maneGrad)" stroke="#1f2937" stroke-width=".6"/>
              <path class="tail" d="M16 30 c -6 4 -8 8 -5 12 c 4 -2 7 -4 10 -7" fill="none" stroke="url(#tailGrad)" stroke-width="3" stroke-linecap="round"/>
              <g transform="translate(24,36)">
                <g transform="translate(-2,0)">
                  <rect class="leg-a" x="0" y="0" width="7" height="12" rx="3" fill="#fff" stroke="#334155" stroke-width=".8"/>
                  <rect class="leg-b" x="10" y="0" width="7" height="12" rx="3" fill="#fff" stroke="#334155" stroke-width=".8"/>
                </g>
                <g transform="translate(18,0)">
                  <rect class="leg-b" x="0" y="0" width="7" height="12" rx="3" fill="#fff" stroke="#334155" stroke-width=".8"/>
                  <rect class="leg-a" x="10" y="0" width="7" height="12" rx="3" fill="#fff" stroke="#334155" stroke-width=".8"/>
                </g>
              </g>
            </g>
          </svg>
        </div>
      </div>

      <div class="ground"></div>

      <!-- Start/help overlay -->
      <div class="overlay" id="help" aria-live="polite">
        <div class="card">
          <h2>Gallop, jump, sparkle ‚ú®</h2>
          <p>
          Type your name, then press <span class="kbd">Space</span> to <strong>start</strong> and jump.<br>
          <strong>Hold</strong> Space for higher/long jumps, or tap for quick hops ‚Äî jump height depends on how long you press.<br>
          (Tap/click only jumps after the run has started.)
          </p>
          <div class="startRow" style="justify-content:center;gap:8px;margin-top:12px">
            <label for="startName">Name</label>
            <input id="startName" class="input" maxlength="12" placeholder="Player" />
          </div>
        </div>
      </div>

      <div class="overlay" id="gameover" style="display:none">
        <div class="card">
          <h2>Game Over üí•</h2>
          <p>Your score: <strong><span id="finalScore">0</span></strong></p>
          <p>Top 10 updates automatically if your score qualifies.</p>
          <p><button id="againBtn" class="btn">Play again</button></p>
        </div>
      </div>
    </div>

    <aside class="board">
      <h3>üèÜ Leaderboard (Top 10)</h3>
      <ol id="topList"><li>Loading‚Ä¶</li></ol>
    </aside>
  </div>
</div>

<!-- Supabase client -->
<script src="https://unpkg.com/@supabase/supabase-js@2.45.4/dist/umd/supabase.js" defer></script>

<script>
(() => {
  "use strict";

  // ======== SUPABASE CONFIG ========
  const SUPABASE_URL = "https://svtihdbdlffwgymbzben.supabase.co";
  const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InN2dGloZGJkbGZmd2d5bWJ6YmVuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUxMTI3MzcsImV4cCI6MjA3MDY4ODczN30.hO_fQVCYfSYNzTjVfbsxBfOs_zlNw3oGarxoUHwvAtA";
  // ==================================

  let supa = null;
  window.addEventListener("load", () => {
    try {
      supa = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
      fetchTop();
    } catch (e) { console.warn("Supabase init failed", e); }
  });

  // ---------- DOM ----------
  const screen = document.getElementById("screen");
  const skyA = document.getElementById("skyA");
  const skyB = document.getElementById("skyB");
  let activeSky = "A";

  const playerEl = document.getElementById("player");
  const spriteEl = document.getElementById("sprite");
  const scoreEl  = document.getElementById("score");
  const bestEl   = document.getElementById("best");
  const speedEl  = document.getElementById("speed");
  const overEl   = document.getElementById("gameover");
  const helpEl   = document.getElementById("help");
  const restartBtn = document.getElementById("restartBtn");
  const againBtn = document.getElementById("againBtn");

  const nameTop = document.getElementById("playerName");
  const nameStart = document.getElementById("startName");
  const topList = document.getElementById("topList");

  // ---------- Name persistence + sync ----------
  const getStoredName = () => localStorage.getItem("unicorn-name") || "Player";
  const setStoredName = (v) => localStorage.setItem("unicorn-name", (v || "Player").slice(0,12));
  const getNameOrDefault = () => {
    const v = (nameTop.value || nameStart.value || "").trim();
    return v || "Player";
  };

  // seed inputs
  const initialName = getStoredName();
  nameTop.value = initialName;
  nameStart.value = initialName;

  // keep inputs in sync
  nameTop.addEventListener("input", () => {
    nameStart.value = nameTop.value.slice(0,12);
    setStoredName(nameTop.value);
  });
  nameStart.addEventListener("input", () => {
    nameTop.value = nameStart.value.slice(0,12);
    setStoredName(nameStart.value);
  });

  // ---------- Game constants ----------
  const GROUND = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--ground-h"));
  const GRAVITY = 2400;         // px/s^2
  const JUMP_KICK = 560;        // px/s
  const JUMP_HOLD_MS = 220;     // ms
  const JUMP_HOLD_BOOST = 1600; // px/s^2 while holding
  const BASE_SPEED = 380;       // px/s (slightly faster base)
  const MAX_SCALE = 2.6;        // higher cap for speed

  // Background milestones (10 stages including 0)
  const BG_THRESHOLDS = [0, 500, 1000, 2000, 3500, 5000, 7000, 10000, 14000, 20000];
  let currentTheme = 0;

  // ---------- State ----------
  let unicorn = { y: GROUND, vy: 0, jumps: 0, alive: true };
  let jumpPressed = false;
  let jumpStartAt = 0;
  let holdLatchUntil = 0;
  let obstacles = []; // {el,x,w,h}
  let clouds = [];    // {el,x,v}
  let running = false;
  let started = false;
  let tPrev = 0;
  let tick = 0;
  let score = 0;
  let best = parseInt(localStorage.getItem("unicorn-best") || "0", 10);
  let speedScale = 1;
  let spawnTimerMs = 0;

  // Drift state for heavy-tailed randomness
  let driftMu = 0;
  let driftSigma = 0;

  function randn(){ // ~N(0,1) with zero-guards
    let u=0, v=0;
    while (u === 0) u = Math.random(); // (0,1]
    while (v === 0) v = Math.random(); // (0,1]
    return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
  }

  bestEl.textContent = String(best).padStart(5, "0");
  applyTheme(0, true);

  // ---------- Utils ----------
  const setTransformX = (el, x) => { el.style.transform = `translate3d(${x}px,0,0)`; };
  const now = () => performance.now();

  // ---------- Clouds ----------
  function ensureClouds(){ while (clouds.length < 4) addCloud(true); }
  function addCloud(init=false){
    const el = document.createElement("div");
    el.className = "cloud";
    const top = 8 + Math.random()*80;
    const x = init ? screen.clientWidth*Math.random() : screen.clientWidth + Math.random()*120;
    el.style.top = top + "px";
    screen.appendChild(el);
    const c = { el, x, v: 28 + Math.random()*40 }; // px/s
    setTransformX(el, x);
    clouds.push(c);
  }

  // ---------- Obstacles ----------
  function addObstacle(){
    const el = document.createElement("div"); el.className = "obstacle";
    const tall = Math.random() < 0.42;
    const w = (tall ? 22 : 18) + Math.floor(Math.random()*3);
    const h = tall ? 56 : 34;
    el.style.width = w + "px"; el.style.height = h + "px";
    screen.appendChild(el);
    const o = { el, x: screen.clientWidth, w, h };
    setTransformX(el, o.x);
    obstacles.push(o);

    // SIBLINGS: directly after with small wobble
    const baseSibling = Math.max(3, 8 - Math.floor(3 * (speedScale - 1)));
    const siblingGapPx = Math.max(2, Math.round(baseSibling + (Math.random()*6 - 3))); // ¬±3px wobble
    const wantDouble = Math.random() < 0.35;
    const wantTriple = wantDouble && Math.random() < 0.15;

    let tail = o;
    function makeSiblingAfter(prev){
      const el2 = document.createElement("div"); el2.className = "obstacle";
      const w2 = (Math.random() < 0.55 ? 18 : 22);
      const h2 = Math.random() < 0.5 ? 34 : 50;
      el2.style.width = w2 + "px"; el2.style.height = h2 + "px";
      const x2 = prev.x + prev.w + siblingGapPx;
      const o2 = { el: el2, x: x2, w: w2, h: h2 };
      setTransformX(el2, o2.x);
      screen.appendChild(el2);
      obstacles.push(o2);
      return o2;
    }
    if (wantDouble)  tail = makeSiblingAfter(tail);
    if (wantTriple)  tail = makeSiblingAfter(tail);
  }

  // ---------- Start & Jump ----------
  function startGame(){
    if (started) return;
    started = true;
    setStoredName(getNameOrDefault());
    helpEl.style.display = "none";
    start();
  }

  function startJump(){
    if(!running) return;
    if(unicorn.jumps >= 1) return;
    unicorn.vy = JUMP_KICK;
    unicorn.jumps++;
    jumpPressed = true;
    jumpStartAt = now();
    holdLatchUntil = jumpStartAt + 45; // ~45ms minimum hold
  }
  function endJump(){ jumpPressed = false; }

  // ---------- Hitboxes ----------
  function deflateRect(r, pad){
    return { left:r.left+(pad.left||0), right:r.right-(pad.right||0), top:r.top+(pad.top||0), bottom:r.bottom-(pad.bottom||0) };
  }
  function overlap(a,b){ return !(a.right < b.left || a.left > b.right || a.bottom < b.top || a.top > b.bottom); }
  const P_PAD = { left:12, right:16, top:8, bottom:2 };
  const O_PAD = { left:2, right:2, top:4, bottom:0 };

  // ---------- Main loop ----------
  function loop(ts){
    try {
      if(!running) return;
      if(!tPrev) tPrev = ts;
      const dt = Math.min(50, ts - tPrev);
      const dtSec = dt / 1000;
      tPrev = ts;

      tick++;

      // Speed ramp
      speedScale = Math.min(MAX_SCALE, 1 + 1.35 * (1 - Math.exp(-score / 4500)));
      speedEl.textContent = speedScale.toFixed(2) + "x";

      // Clouds
      for(let i=clouds.length-1;i>=0;i--){
        const c = clouds[i];
        c.x -= c.v * dtSec * (0.7 + 0.6*(speedScale-1));
        setTransformX(c.el, c.x);
        if(c.x < -90){ c.el.remove(); clouds.splice(i,1); addCloud(false); }
      }

      // ----- Spawns (time-based, refresh-rate independent) -----
      if (spawnTimerMs <= 0) {
        addObstacle();

        // Current world speed
        const worldPxPerSec = BASE_SPEED * Math.max(1, speedScale);

        // Fair minimum distance (room to land at high speed)
        const minWorldGapPx =
          240 + Math.max(0, 120 - score / 4) + 90 * (speedScale - 1);

        // Minimum as time
        const minMs = Math.ceil((minWorldGapPx / worldPxPerSec) * 1000);

        // Heavy-tailed extra distance via log-normal, with slow drift
        driftMu    = 0.92 * driftMu    + 0.08 * randn();
        driftSigma = 0.85 * driftSigma + 0.15 * randn();

        let medianExtraPx = (Math.random() < 0.55 ? 120 : 300) + 60 * (speedScale - 1);
        medianExtraPx *= (1 + 0.35 * Math.tanh(driftMu));

        let sigmaLN = 1.0 + 0.35 * (speedScale - 1) + 0.35 * Math.tanh(driftSigma);
        sigmaLN = Math.max(0.8, Math.min(1.7, sigmaLN));

        const muLN = Math.log(Math.max(1, medianExtraPx));
        const extraPx = Math.exp(muLN + sigmaLN * randn());

        // Occasional micro-burst cluster
        let burstClampPx = Infinity;
        if (Math.random() < 0.22) burstClampPx = 80 + 90 * Math.random();

        const gapWorldPx = minWorldGapPx + Math.min(extraPx, burstClampPx);

        // Convert to ms and clamp
        let sampleMs = Math.round((gapWorldPx / worldPxPerSec) * 1000);
        const maxMs = Math.min(
          1100,
          Math.ceil(((minWorldGapPx + 700) / worldPxPerSec) * 1000)
        );

        if (!Number.isFinite(sampleMs)) sampleMs = minMs + 120;
        spawnTimerMs = Math.max(minMs + 30, Math.min(maxMs, sampleMs));
      }

      // Drain timer by real elapsed time + guards
      spawnTimerMs -= dt;
      if (!Number.isFinite(spawnTimerMs)) spawnTimerMs = 300;
      if (spawnTimerMs < -300) spawnTimerMs = -300;
      if (obstacles.length === 0 && spawnTimerMs > 1200) spawnTimerMs = 120;

      // Move obstacles & collisions
      const px = BASE_SPEED * speedScale * dtSec;
      const unicornRect = deflateRect(playerEl.getBoundingClientRect(), P_PAD);

      for(let i=obstacles.length-1;i>=0;i--){
        const o = obstacles[i];
        o.x -= px;
        setTransformX(o.el, o.x);
        const r = deflateRect(o.el.getBoundingClientRect(), O_PAD);
        if(overlap(unicornRect, r)){ endGame(); break; }
        if(o.x < -o.w - 12){ o.el.remove(); obstacles.splice(i,1); }
      }

      // Physics
      let ay = -GRAVITY;
      if ((jumpPressed || now() < holdLatchUntil) &&
          (now() - jumpStartAt) < JUMP_HOLD_MS &&
          unicorn.vy > 0) {
        ay += JUMP_HOLD_BOOST;
      }
      unicorn.vy += ay * dtSec;
      unicorn.y = Math.max(GROUND, unicorn.y + unicorn.vy * dtSec);
      if(unicorn.y === GROUND){
        unicorn.vy = 0; unicorn.jumps = 0;
        spriteEl.classList.add("run");
      } else {
        spriteEl.classList.remove("run");
      }
      playerEl.style.bottom = unicorn.y + "px";

      // Score & best
      score += Math.max(1, Math.floor(1.2 * speedScale));
      if(score > best){
        best = score;
        localStorage.setItem("unicorn-best", String(best));
        bestEl.textContent = String(best).padStart(5,"0");
      }
      scoreEl.textContent = String(score).padStart(5,"0");

      // Background
      updateBackground(score);
    } catch (err) {
      console.error("Game loop error:", err);
      // keep the loop alive
    }
    if (running) requestAnimationFrame(loop);
  }

  // ---------- Lifecycle ----------
  function start(){
    obstacles.forEach(o=>o.el.remove()); obstacles=[];
    clouds.forEach(c=>c.el.remove()); clouds=[];
    score=0; tick=0; speedScale=1; spawnTimerMs=300;
    driftMu=0; driftSigma=0; // reset drift each run
    unicorn = { y: GROUND, vy: 0, jumps: 0, alive: true };
    playerEl.style.bottom = GROUND + "px";
    playerEl.classList.remove("dead");
    spriteEl.classList.remove("run");
    ensureClouds();
    applyTheme(0, true);
    running = true;
    requestAnimationFrame(loop);
  }
  function endGame(){
    running = false; unicorn.alive = false; playerEl.classList.add("dead");
    document.getElementById("finalScore").textContent = String(score);
    overEl.style.display = "";
    submitScore(getNameOrDefault(), score).catch(()=>{});
  }
  function restart(){ overEl.style.display="none"; tPrev=0; start(); }

  // ---------- Input ----------
  window.addEventListener("keydown", (e) => {
    if (e.code === "Space") {
      if (!started) {
        e.preventDefault();
        setStoredName(getNameOrDefault());
        startGame();
        startJump(); // immediate first jump
      } else {
        e.preventDefault();
        startJump();
      }
    } else if (e.code === "KeyR") {
      e.preventDefault();
      restart();
    }
  }, { passive:false });

  window.addEventListener("keyup", (e)=> {
    if(e.code === "Space"){ endJump(); }
  });

  // Tap/click should NOT start the game. Allow jump only after started.
  screen.addEventListener("pointerdown", () => { if (started) startJump(); }, { passive:true });
  window.addEventListener("pointerup", () => endJump(), { passive:true });

  // Restart buttons
  restartBtn.addEventListener("click", () => { started=true; restart(); });
  if (againBtn) againBtn.addEventListener("click", () => { started=true; restart(); });

  // ---------- Leaderboard ----------
  async function submitScore(name, score){
    try {
      if (!supa) { supa = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY); }
      name = (name || "Player").slice(0,12).replace(/[<>]/g,'');
      const { error } = await supa.from("scores").insert({ name, score });
      if (error) throw error;
      await fetchTop();
    } catch (e) {
      console.warn("submitScore failed", e);
      if (topList) topList.innerHTML = '<li>(leaderboard error ‚Äî check RLS policies on "scores")</li>';
    }
  }
  async function fetchTop(){
    if (!supa || !topList) return;
    try {
      const { data, error } = await supa
        .from("scores")
        .select("name,score")
        .order("score", { ascending:false })
        .limit(10);
      if (error) throw error;
      renderTop(data || []);
    } catch(e){
      topList.innerHTML = "<li>(leaderboard unavailable)</li>";
    }
  }
  function renderTop(rows){
    if(!rows.length){ topList.innerHTML = "<li>No scores yet ‚Äî be first!</li>"; return; }
    topList.innerHTML = rows.map((r,i)=>(`<li><strong>${escapeHtml(r.name||"Player")}</strong> ‚Äî ${r.score}</li>`)).join("");
  }
  function escapeHtml(s){ return s.replace(/[&<>\"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

  // ---------- Background crossfade ----------
  function updateBackground(scoreVal){
    let idx = 0;
    for (let i = BG_THRESHOLDS.length - 1; i >= 0; i--) {
      if (scoreVal >= BG_THRESHOLDS[i]) { idx = i; break; }
    }
    if (idx !== currentTheme){ applyTheme(idx); }
  }
  function applyTheme(idx, immediate=false){
    currentTheme = idx;
    const showEl = (activeSky === "A") ? skyB : skyA;
    const hideEl = (activeSky === "A") ? skyA : skyB;

    showEl.className = `sky theme-${idx}` + (immediate ? " visible" : "");

    if (immediate){
      hideEl.classList.remove("visible");
      activeSky = (activeSky === "A") ? "B" : "A";
      return;
    }

    // force reflow to ensure transition applies
    void showEl.offsetWidth;

    hideEl.classList.remove("visible");
    showEl.classList.add("visible");
    activeSky = (activeSky === "A") ? "B" : "A";
  }
})();
</script>
</body>
</html>
